<!DOCTYPE html>

<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta charset="utf-8">
    <title>CB4J - User guide</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="benas">

    <link href="../resources/css/bootstrap.min.css" rel="stylesheet">
    <link href="../resources/css/prettify.css" rel="stylesheet">
    <style type="text/css">
        body {
            padding-top: 60px;
            padding-bottom: 40px;
            background-image: url('../resources/img/background.png');
        }
        .sidebar-nav {
            padding: 9px 0;
        }
        .section {
            padding-top: 40px;
        }
    </style>
    <link href="../resources/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="../resources/css/font-awesome.css" rel="stylesheet">
    <link href="../resources/css/sidebar.css" rel="stylesheet">

    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <script type="text/javascript" src="../resources/js/prettify.js"></script>

</head>

<body onload="prettyPrint()">

<div class="navbar navbar-inverse navbar-fixed-top">
    <div class="navbar-inner">
        <div class="container">
            <a class="brand" href="../index.html">CB4J</a>
            <div class="nav-collapse collapse">
                <p class="navbar-text pull-right">Version: 1.4.0</p>
                <ul class="nav">
                    <li><a href="../index.html"><i class="icon-home"></i> Home</a></li>
                    <li class="dropdown active">
                        <a id="documentation" href="#" role="button" class="dropdown-toggle" data-toggle="dropdown"><i class="icon-book"></i> Documentation<b class="caret"></b></a>
                        <ul class="dropdown-menu" role="menu" aria-labelledby="documentation">
                            <li><a href="gettingStarted.html">Getting started</a></li>
                            <li><a href="architecture.html">Architecture</a></li>
                            <li><a href="userGuide.html">User Guide</a></li>
                            <li><a href="faq.html">CB4J FAQ</a></li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a id="tutorials" href="#" role="button" class="dropdown-toggle" data-toggle="dropdown"><i class="icon-folder-open"></i> Tutorials<b class="caret"></b></a>
                        <ul class="dropdown-menu" role="menu" aria-labelledby="tutorials">
                            <li><a href="../tutorials/helloworld.html">Hello World!</a></li>
                            <li><a href="../tutorials/customers.html">Customers ETL</a></li>
                            <li><a href="../tutorials/products.html">Product Statistics</a></li>
                            <li><a href="../tutorials/library.html">Book Library</a></li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a id="miscellaneous" href="#" role="button" class="dropdown-toggle" data-toggle="dropdown"><i class="icon-asterisk"></i> Miscellaneous<b class="caret"></b></a>
                        <ul class="dropdown-menu" role="menu" aria-labelledby="miscellaneous">
                            <li><a href="../miscellaneous/spring.html">Using Spring with CB4J</a></li>
                            <li><a href="../miscellaneous/quartz.html">Scheduling CB4J with Quartz</a></li>
                            <li><a href="../miscellaneous/jmx.html">Monitoring CB4J with JMX</a></li>
                            <li><a href="../miscellaneous/beanValidation.html">Using Bean Validation</a></li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</div>

<div class="container">
    <div class="row-fluid">

    <div class="span3">
        <div class="well sidebar-nav bs-docs-sidenav" data-spy="affix">
                <ul class="nav nav-list">
                    <li class="nav-header">About CB4J</li>
                    <li><a href="../index.html">Overview</a></li>
                    <li><a href="../releaseNotes.html">Release notes</a></li>
                    <li class="nav-header">Documentation</li>
                    <li><a href="gettingStarted.html">Getting started</a></li>
                    <li><a href="architecture.html">Architecture</a></li>
                    <li class="active">
                        <a href="userGuide.html">User Guide</a>
                        <ul>
                            <li><a href="userGuide.html#1">1. Introduction</a></li>
                            <li><a href="userGuide.html#2">2. Using CB4J</a></li>
                            <li><a href="userGuide.html#3">3. Extending CB4J</a></li>
                        </ul>
                    </li>
                    <li><a href="faq.html">CB4J FAQ</a></li>
                    <li class="nav-header">Tutorials</li>
                    <li><a href="../tutorials/helloworld.html">Hello World!</a></li>
                    <li><a href="../tutorials/customers.html">Customers ETL</a></li>
                    <li><a href="../tutorials/products.html">Product Statistics</a></li>
                    <li><a href="../tutorials/library.html">Book Library</a></li>
                    <li class="nav-header">Miscellaneous</li>
                    <li><a href="../miscellaneous/spring.html">Using Spring with CB4J</a></li>
                    <li><a href="../miscellaneous/quartz.html">Scheduling CB4J with Quartz</a></li>
                    <li><a href="../miscellaneous/jmx.html">Monitoring CB4J with JMX</a></li>
                    <li><a href="../miscellaneous/beanValidation.html">Using Bean Validation</a></li>
                </ul>
            </div>
        </div>

        <div class="span9">

            <div class="page-header">
                <h1>User Guide</h1>
            </div>

            <div class="row-fluid">

            <h2 id="1">1. Introduction</h2>

            <p>To work effectively with CB4J, you have to follow these simple three steps:</p>
            <ul>
                <li>Provide configuration parameters (Input file path, file encoding,field delimiter,etc)</li>
                <li>Provide data validation constraints (field size, data type and format,etc) that will be used by the record validator to validate data</li>
                <li>Register record processing business logic that will be applied by the record processor</li>
            </ul>
            
            <p>All these steps can be done through the <code class="prettyprint">BatchConfiguration</code> class which is the main entry point to configure the engine.</p>

            <h2 id="2" class="section">2. Using CB4J</h2>

            <h3 id="2.1">2.1 Configuring the engine</h3>

            <p>To configure CB4J, you must supply a set of predefined parameters (see table below). You can configure CB4J in 3 ways:</p>

            <ul>
                <li>With a <code class="prettyprint">java.util.Properties</code> object instance</li>
                <li>With a standard Java (key,value pairs or xml) properties file</li>
                <li>With a <code class="prettyprint">BatchConfigurationBuilder</code> object instance</li>
            </ul>

            <p>All configuration parameters are defined in the <code class="prettyprint">io.github.benas.cb4j.core.util.BatchConstants</code> class and described in the following table:</p>

            <table class="table table-bordered table-striped">
                <thead>
                <tr>
                    <th>Parameter</th>
                    <th>Description</th>
                    <th>Required</th>
                    <th>Default Value</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>input.data.path</td>
                    <td>absolute path of input data file</td>
                    <td>true</td>
                    <td>N/A</td>
                </tr>
                <tr>
                    <td>input.data.encoding</td>
                    <td>input data file encoding</td>
                    <td>false</td>
                    <td>System default encoding</td>
                </tr>
                <tr>
                    <td>input.data.skipHeader</td>
                    <td>Specify if the first record should be skipped. If set to true, the header record is escaped from record numbering</td>
                    <td>false</td>
                    <td>false</td>
                </tr>
                <tr>
                    <td>input.record.type</td>
                    <td>Specify the record type : Delimiter-Separated Values (DSV) or Fixed-Length Record (FLR)</td>
                    <td>false</td>
                    <td>DSV</td>
                </tr>
                <tr>
                    <td>input.record.class</td>
                    <td>Specify the fully qualified class name of the domain object to map CSV/FL records to</td>
                    <td>false</td>
                    <td>the class name used in record processor implementation</td>
                </tr>
                <tr>
                    <td>input.record.headers</td>
                    <td>Comma separated list of field names to be mapped to domain object fields.</td>
                    <td>false</td>
                    <td>field names declared in header record</td>
                </tr>
                <tr>
                    <td>input.field.delimiter</td>
                    <td>When using DSV record type, this parameter is used to specify the delimiter</td>
                    <td>false</td>
                    <td>comma ','</td>
                </tr>
                <tr>
                    <td>input.field.lengths</td>
                    <td>When using FRL record type, this parameter is used to specify fields lengths as a comma separated values. Example: 3,5,4,10</td>
                    <td>true (only for FLR)</td>
                    <td>N/A</td>
                </tr>
                <tr>
                    <td>input.field.trim</td>
                    <td>Specify if whitespaces should be trimmed</td>
                    <td>false</td>
                    <td>true</td>
                </tr>
                <tr>
                    <td>input.field.qualifier</td>
                    <td>Specify data qualifier character</td>
                    <td>false</td>
                    <td>empty character</td>
                </tr>
                <tr>
                    <td>input.record.size</td>
                    <td>Record size (number of fields)</td>
                    <td>false</td>
                    <td>header record size</td>
                </tr>
                <tr>
                    <td>output.data.ignored</td>
                    <td>Absolute path to the log file of ignored records</td>
                    <td>false</td>
                    <td>${input.data.path}-ignored.log. The extension of the input data file (if any) will be removed</td>
                </tr>
                <tr>
                    <td>output.data.rejected</td>
                    <td>Absolute path to the log file of rejected records</td>
                    <td>false</td>
                    <td>${input.data.path}-rejected.log. The extension of the input data file (if any) will be removed</td>
                </tr>
                <tr>
                    <td>output.data.errors</td>
                    <td>Absolute path to the log file of error records</td>
                    <td>false</td>
                    <td>${input.data.path}-errors.log. The extension of the input data file (if any) will be removed</td>
                </tr>
                <tr>
                    <td>output.data.abortOnFirstReject</td>
                    <td>Specify if the engine should abort batch execution on first reject</td>
                    <td>false</td>
                    <td>false</td>
                </tr>
                <tr>
                    <td>output.data.abortOnFirstError</td>
                    <td>Specify if the engine should abort batch execution on first record processing error</td>
                    <td>false</td>
                    <td>false</td>
                </tr>
                <tr>
                    <td>output.data.abortOnFirstMappingException</td>
                    <td>Specify if the engine should abort batch execution on first record mapping exception</td>
                    <td>false</td>
                    <td>false</td>
                </tr>
                <tr>
                    <td>output.data.jmx.enabled</td>
                    <td>Specify if JMX monitoring feature should be enabled/disabled</td>
                    <td>false</td>
                    <td>true</td>
                </tr>
                </tbody>
            </table>

            <h4>2.1.1 Loading parameters from a Java Properties object instance</h4>
            <p>To load configuration parameters from a <code class="prettyprint">java.util.Properties</code> instance, use the following snippet:</p>

<pre class="prettyprint">
Properties configurationProperties = new Properties();
configurationProperties.setProperty("input.data.path","/data/cb4j/myData.csv");
configurationProperties.setProperty("input.record.size","7");

BatchConfiguration batchConfiguration = new BatchConfiguration(configurationProperties);
</pre>

            <h4>2.1.2 Loading parameters from a Java Properties file</h4>
            <p>You can load parameters from a configuration file in the file system or the classpath. The following is an example of a configuration file named <code class="prettyprint">"/data/cb4j/myConfig.cfg"</code>:</p>

<pre>
input.data.path=/data/cb4j/myData.csv
input.record.size=7
</pre>

            <p>To use this configuration file with CB4J, you can use the following snippet:</p>

<pre class="prettyprint">
BatchConfiguration batchConfiguration = new FileSystemBatchConfiguration("/data/cb4j/myConfig.cfg");
</pre>
            <span class="label label-info">Info</span> If the configuration file is in the classpath, you can use the <code class="prettyprint">ClassPathBatchConfiguration</code> class instead and supply the file name to its constructor.

            <h4>2.1.3 Loading parameters from a Java Properties xml file</h4>
            <p>You can load parameters from an xml configuration file in the file system or the classpath. The following is an example of a configuration file named <code class="prettyprint">"/data/cb4j/myConfig.xml"</code>:</p>

<pre class="prettyprint">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"&gt;
&lt;properties&gt;
    &lt;comment&gt;my batch configuration&lt;/comment&gt;
    &lt;entry key="input.data.path"&gt;/data/cb4j/myData.csv&lt;/entry&gt;
    &lt;entry key="input.record.size"&gt;7&lt;/entry&gt;
&lt;/properties&gt;
</pre>

            <p>To use this configuration file with CB4J, you can use the following snippet:</p>

<pre class="prettyprint">
BatchConfiguration batchConfiguration = new FileSystemXmlBatchConfiguration("/data/cb4j/myConfig.xml");
</pre>
            <span class="label label-info">Info</span> If the configuration file is in the classpath, you can use the <code class="prettyprint">ClassPathXmlBatchConfiguration</code> class instead and supply the file name to its constructor.

            <h4>2.1.4 Using a BatchConfigurationBuilder object instance</h4>
            <p>The <code class="prettyprint">BatchConfigurationBuilder</code> class is an implementation of the builder pattern that allows you to set configuration parameters programmatically without worrying about parameters names.</p>
            <p>This class provides convenient methods to set each parameter with an appropriate method name. The following snippet shows how to user this builder to configure CB4J:</p>

<pre class="prettyprint">
BatchConfiguration batchConfiguration = new BatchConfigurationBuilder()
        .inputDataFile("/data/cb4j/myData.csv")
        .recordSize(7)
        .delimiter(";")
        .skipHeader(true)
        .build();
</pre>

            <p>For all details about available methods, please refer to the javadoc of <code class="prettyprint">BatchConfigurationBuilder</code> class.</p>

            <h4>2.1.5 Configuring CB4J engine</h4>
            <p>Once you have initialized CB4J with all parameters (and registered mandatory services, see next section ), you can configure the engine as follows:</p>

<pre class="prettyprint">
try {
    batchConfiguration.configure();
} catch (BatchConfigurationException e) {
    System.err.println(e.getMessage());
}
</pre>

            <div class="alert alert-info">
                <span class="label label-info">Info</span> CB4J throws a <code class="prettyprint">BatchConfigurationException</code> in the following cases:
                <ul>
                    <li>One of the mandatory parameters is not specified</li>
                    <li>No record processor specified</li>
                    <li>A <code class="prettyprint">java.io.FileNotFoundException</code> is thrown when trying to open the input file</li>
                    <li>Log files for ignored and rejected records cannot be used</li>
                </ul>
            </div>

            <h3 id="2.2">2.2 Validating data</h3>

            <h4>2.2.1 Using built-in validators</h4>

            <p>CB4J validates field data with implementations of <code class="prettyprint">FieldValidator</code> interface and comes with built-in validators which allow you to ensure that a field content has a valid format and type. These validators are located in the <code class="prettyprint">io.github.benas.cb4j.core.validator</code> package.</p>

            <p>For example, let's say that the first field's value must be numeric. With CB4J you simply declare this constraint using the <code class="prettyprint">NumericFieldValidator</code> as follows:</p>

            <code class="prettyprint">batchConfiguration.registerFieldValidator(1, new NumericFieldValidator());</code>

            <h4>2.2.2 Registering multiple validators</h4>

            <p>You may want to apply multiple validation constraints to a single field. For example, the first field must not be empty and must be a date value having the <code class="prettyprint">dd/MM/yyyy</code> format.
            To register multiples validators for this field, you have to declare a list containing all validators:</p>

<pre class="prettyprint">
List&lt;FieldValidator&gt; field1Validators = new ArrayList&lt;FieldValidator&gt;();
field1Validators.add(new NotEmptyFieldValidator());
field1Validators.add(new DateFieldValidator("dd/MM/yyyy"));

batchConfiguration.registerFieldValidators(1,field1Validators);
</pre>

            <div class="alert alert-info">
                <span class="label label-info">Info</span> When using multiple validators, the validation order applied by CB4J is the insertion order of validators in the list.
            </div>

            <h3 id="2.3">2.3 Mapping records to Java objects</h3>

            <p>To map a CSV/FL record to your domain Java object, you can :</p>
            <ul>
                <li>Use the default mapper provided by CB4J</li>
                <li>Provide your own mapper by implementing the <code class="prettyprint">RecordMapper&lt;T&gt;</code> interface</li>
            </ul>
            <h4 id="2.3.1">2.3.1 Using the default mapper</h4>

            <p>CB4J comes with a default <code class="prettyprint">RecordMapper&lt;T&gt;</code> implementation that is based on field names in header record to map data to domain object fields with the same name.</p>
            <p>For example, let's say your CSV file and domain object are respectively the following :</p>
<pre class="prettyprint">
sequence,name
1,Foo
2,Bar
</pre>

<pre class="prettyprint">
public class Greeting {

    private long sequence;

    private String name;

    // Getters and Setters omitted

}
</pre>

            <p>CB4J will use field names in header record to map data to fields in <code class="prettyprint">Greeting</code> class with the same name.</p>
            <p>In this example, the first field <code class="prettyprint">sequence</code> in CSV record will be mapped to the field <code class="prettyprint">sequence</code> in <code class="prettyprint">Greeting</code> Object. This is the same for the <code class="prettyprint">name</code> field. The figure below shows how the default mapper works:</p>

            <div align="center"><img src="../resources/img/csv-pojo-mapping.png"/></div>

            <div class="alert alert-info">
                <p><span class="label label-info">Info</span> if your CSV file does not contain a header record with field names, you can specify them using the <code class="prettyprint">input.record.headers</code> parameter.</p>
                <p><span class="label label-info">Info</span> Your domain object must provide a default constructor and a setter for each field (so that CB4J can instantiate your object and bind CSV data to its fields).</p>
            </div>

            <p>CB4J will also convert raw textual data in your CSV file to typed data according to field type of the domain object. For instance, <code class="prettyprint">sequence</code> values in CSV records will be converted to the type <code class="prettyprint">long</code> as defined in <code class="prettyprint">Greeting</code> Object.</p>
            <p>By default, CB4J can convert textual data to common built-in Java types such as Boolean, Integer, Date, etc. For all details about supported types, please refer to the package <code class="prettyprint">io.github.benas.cb4j.core.converter</code>.</p>
                You can also provide your own type converter by implementing the <code class="prettyprint">io.github.benas.cb4j.core.api.TypeConverter</code> interface and registering your implementation as follows:
<pre class="prettyprint">
batchConfiguration.registerTypeConverter(MyType.class, new myTypeConverter());
</pre>

            <div class="alert">
                <span class="label label-warning">Warning</span> The default mapper uses the <a href="http://docs.oracle.com/javase/tutorial/reflect/index.html">Java Reflection API</a> to dynamically introspect your domain object properties and populate them with CSV data.
                <p>If your application is performance sensitive, you would prefer implementing your own mapper without using reflection. This can result to about <strong>10x</strong> faster code than using reflection as demonstrated in <a href="https://github.com/benas/cb4j/blob/master/cb4j-core/src/test/java/io/github/benas/cb4j/core/test/ReflectionPerformanceShowcase.java">the benchmark here</a>.</p>
            </div>

            <h4 id="2.3.2">2.3.2 Provide custom mapping logic</h4>

            <p>As you have seen, the default mapper provides one-to-one mapping between CSV/FL record and your domain object. This may not be what you want if a record actually contains data corresponding to multiple nested domain objects or if you want to apply some data transformation before mapping values.</p>
            <p>To provide your custom Record/Object mapping, you have to implement the <code class="prettyprint">RecordMapper&lt;T&gt;</code> interface and register your implementation at configuration time as follows:</p>
            <p><code class="prettyprint">batchConfiguration.registerRecordMapper(new MyRecordMapper());</code></p>
            
            <p>The <a href="../tutorials/customers.html">customers ETL tutorial</a> shows an example of a custom record mapper implementation.</p>
            
            <h3 id="2.4">2.4 Writing processing logic</h3>

            <p>When using CB4J, you process an object view of a record. To define your record processing business logic, you have to implement the <code class="prettyprint">RecordProcessor&lt;T&gt;</code> interface and register your implementation at configuration time as follows:</p>
            <p><code class="prettyprint">batchConfiguration.registerRecordProcessor(new MyRecordProcessor());</code></p>

            <div class="alert alert-error">
                <span class="label label-important">Important</span> When you decide to use your own record mapper instead of the default one, you have to use the <strong>same</strong> type T when implementing <code class="prettyprint">RecordMapper&lt;T&gt;</code> and <code class="prettyprint">RecordProcessor&lt;T&gt;</code> interfaces
            </div>

            <h3 id="2.5">2.5 Writing rollback logic</h3>

            <p>CB4J provides basic transaction support through the <code class="prettyprint">io.github.benas.cb4j.core.api.RollBackHandler</code> interface:</p>
<pre class="prettyprint">
public interface RollBackHandler&lt;T&gt; {

    public void rollback(T typedRecord) throws Exception;

}
</pre>
            <p>This interface is a callback interface that allows you to define the rollback code to execute whenever an unexpected exception occurs during record processing.</p>
            <p>To register you rollback handler, use the method <code class="prettyprint">registerRollBackHandler</code> of <code class="prettyprint">BatchConfiguration</code> class as follows:</p>

<pre class="prettyprint">
batchConfiguration.registerRollBackHandler(new myRollBackHandler());
</pre>

            <div class="alert alert-info">
                <span class="label label-info">Note</span> Your roll back handler will not be called if you throw <strong>deliberately</strong> a <code class="prettyprint">RecordProcessingException</code> during record processing. It is executed only when an unexpected exception occurs.
            </div>

            <h3 id="2.6">2.6 Running the batch</h3>

            <p>Once you have configured CB4J using the configuration API, you can launch the batch execution as follows:</p>

<pre class="prettyprint">
BatchEngine batchEngine = new DefaultBatchEngineImpl(batchConfiguration);
BatchRunner batchRunner = new BatchRunner(batchEngine);
batchRunner.run();
</pre>

            <p>CB4J provides the <code class="prettyprint">BatchReport</code> API which allows you to get a batch report about the processing time, batch start/end dates, the number of ignored/rejected/errors, etc</p>
            <p>Moreover, there are many use cases when one need to get some computation result at the end of batch execution.
                CB4J provides also the <code class="prettyprint">BatchResultHolder</code> API that allows you to get batch result at the end of execution.
                To use this API, you can implement the <code class="prettyprint">getBatchResultHolder</code> method in <code class="prettyprint">RecordProcessor</code>
                interface or override this method in <code class="prettyprint">DefaultRecordProcessorImpl</code> class.</p>

            <p>Then, you can use these API as follows:</p>

<pre class="prettyprint">
BatchEngine batchEngine = new DefaultBatchEngineImpl(batchConfiguration);
BatchRunner batchRunner = new BatchRunner(batchEngine);
BatchReport batchReport = batchRunner.run();
BatchResultHolder batchResultHolder = batchReport.getBatchReportHolder();
MyResult myResult = batchResultHolder.getResult();
</pre>

            <p>The <code class="prettyprint">BatchResultHolder&lt;R&gt;</code> API is a generic interface that allows you to define the result type according to your needs. A usage example of these APIs is shown in the
                <a href="../tutorials/products.html">products statistics tutorial</a> where the goal of the batch is to compute some statistics on products prices.</p>


            <h2 id="3" class="section">3. Extending CB4J</h2>

            <p>Although CB4J comes with default implementation of common requirements, it lets you extend these defaults as you need.
            In this section, we will show how you can extend CB4J to meet you custom requirements.</p>

            <div class="alert alert-info">
                <span class="label label-info">Info</span> In this section, <code class="prettyprint">batchConfiguration</code> is supposed to be a <code class="prettyprint">BatchConfiguration</code> instance correctly configured with CB4J parameters.
            </div>

            <h3 id="3.1">3.1 Writing a custom batch engine</h3>

            <p>The internal CB4J engine extends the <code class="prettyprint">java.util.concurrent.Callable</code> interface with two methods to initialize and shutdown the engine:</p>
<pre class="prettyprint">
public interface BatchEngine extends Callable&lt;BatchReport&gt; {

    /**
    * initialize the engine
    */
    public void init();

    /**
    * shutdown the engine
    */
    public void shutdown();

}
</pre>
            <p>By default, the <code class="prettyprint">DefaultBatchEngineImpl</code> logs a message to the console to signal batch starting and ending steps.<br/>
            To override this default behavior, you have to extend the <code class="prettyprint">DefaultBatchEngineImpl</code> and override <code class="prettyprint">init()</code> and/or <code class="prettyprint">shutdown()</code> methods to provide a custom initializing and/or shutdown code. For instance, this is where you can open/close a database connection.<br/>
            The <a href="../tutorials/products.html">products statistics tutorial</a> shows an example of how to override the the <code class="prettyprint">DefaultBatchEngineImpl</code>.</p>

            <div class="alert">
                <span class="label label-warning">Warning</span> When you override init() and shutdown() methods, consider calling the super methods because CB4J sets JMX attributes in these methods such as batch status and record statistics. Not calling super methods may introduce incorrect statistics reported by CB4J's JMX MBean.
            </div>
            <h3 id="3.2">3.2 Writing a custom field validator</h3>

            <p>CB4J comes with basic field validators for common requirements such as not empty field, numeric values, etc.
            Please refer to the javadoc of <code class="prettyprint">io.github.benas.cb4j.core.validator</code> package for more details.</p>

            <p>To write a custom field validator, you have to implement the <code class="prettyprint">FieldValidator</code> interface. This interface contains the following methods:</p>
            <ul>
                <li><code class="prettyprint">public boolean isValid(final Field field)</code>: This method should contain the validation logic for a field</li>
                <li><code class="prettyprint">public String getValidationConstraintDescription()</code>: This method should return a description of the validation constraint implemented by the validator. This description will be used to report the cause of record rejection</li>
            </ul>

            <p>In this section, we will show an example of custom validator which validates that a field value must start with the string 'XP'.</p>

<pre class="prettyprint">
public class MyCustomFieldValidator implements FieldValidator {

    public boolean isValid(final Field field) {
        return field.getContent().startsWith("XP");
    }

    public String getValidationConstraintDescription() {
        return "field content must start with XP";
    }

}
</pre>

            <p>To register this validator for the field at index 1, use the following CB4J API:</p>

<pre class="prettyprint">
batchConfiguration.registerFieldValidator(1,new MyCustomFieldValidator());
</pre>


            <h3 id="3.3">3.3 Writing a custom record validator</h3>

<p>            By default, CB4J considers a record as valid if all its fields are valid according to declared validation constraints. But this default behavior works only if validation logic for each field is independent form other fields.

            CB4J provides a simple way to extend this default behavior if validation constraints involve multiple fields at the same time.</p>

           <p> In this section, we will use the following record format as example:</p>

<pre>
field1;field2
foo;foobar
foo;boobar
</pre>

            <p>The validation constraints are the following:</p>
            <ul>
                <li>All fields are required</li>
                <li>field1 should have a length of 3 characters</li>
                <li>field2 content must start with field1's content</li>
            </ul>

            <p>As you can see, this requirement cannot be implemented using the default CB4J validation.
            Conditions 1 and 2 can be implemented by declaring regular field validators, but not Condition 3 which involves field1 and field2 at the same time. This validation requirement should be done at record level and not field level.</p>
            <p>We should extend the default behavior with a custom record validator. To do this, we will extend the <code class="prettyprint">DefaultRecordValidatorImpl</code> class and override the <code class="prettyprint">validateRecord(Record record)</code> method:<p/>

<pre class="prettyprint">
public class MyCustomRecordValidator extends DefaultRecordValidatorImpl {

    public MyCustomRecordValidator(Map&lt;Integer, List&lt;FieldValidator&gt;&gt; fieldValidators) {
        super(fieldValidators);
    }

    @Override
    public String validateRecord(final Record record) {

        String error = super.validateRecord(record);
        if (error == null) { //no errors after applying declared validators on each field

            //add custom validation: field 2 content must start with field's 1 content
            final String content1 = record.getFieldContentByIndex(0);
            final String content2 = record.getFieldContentByIndex(1);
            if (!content2.startsWith(content1)) {
             return "field 2 [" + content2 + "] must start with field 1 [" + content1 + "]";
            }
        }
        return null; //null means no error
    }
}
</pre>

            <p>Once the custom validator implemented, we should tell CB4J to use it instead of the default one. This is done with the following API:</p>

<pre class="prettyprint">
Map&lt;Integer, List&lt;FieldValidator&gt;&gt; fieldValidators = new HashMap&lt;Integer, List&lt;FieldValidator&gt;&gt;();

List&lt;FieldValidator> field1Validators = new ArrayList&lt;FieldValidator&gt;();
final NotEmptyFieldValidator notEmptyFieldValidator = new NotEmptyFieldValidator();
field1Validators.add(notEmptyFieldValidator);
field1Validators.add(new FixedLengthFieldValidator(3));

List&lt;FieldValidator> field2Validators = new ArrayList&lt;FieldValidator&gt;();
field2Validators.add(notEmptyFieldValidator);

fieldValidators.put(0, field1Validators);
fieldValidators.put(1, field2Validators);

MyCustomRecordValidator myCustomRecordValidator = new MyCustomRecordValidator(fieldValidators);
batchConfiguration.registerRecordValidator(myCustomRecordValidator);
</pre>

            <div class="alert alert-info">
                <span class="label label-info">Info</span> field indexes in records are zero-based.
            </div>

            <h3 id="3.4">3.4 Writing a custom reporter</h3>

            <p>By default, CB4J generates a minimal report at the end of batch execution. An example of the default report is shown below:</p>

<pre>
[CB4J: INFO] CB4J report:
[CB4J: INFO] Start time = Sat Dec 01 21:21:17 CET 2013
[CB4J: INFO] End time = Sat Dec 01 21:21:17 CET 2013
[CB4J: INFO] Batch duration = 2ms
[CB4J: INFO] Total input records = 3
[CB4J: INFO] Total ignored records = 1
[CB4J: INFO] Total rejected records = 1
[CB4J: INFO] Total records processed successfully = 1
[CB4J: INFO] Total records processed with error = 0
</pre>

            <p>As you can see, CB4J reports to the console the batch start time, end time , overall execution duration and other metrics about input records.
                This simple report may not correspond to your requirement. Hence, CB4J lets you extend or override it as you need.</p>

            <p>In this section ,we will show how to override the default report with a chart report using the Java free charting library <a href="http://www.jfree.org/jfreechart/">jfreechart</a>.
                To override the default reporter behavior, we have to extend the <code class="prettyprint">DefaultBatchReporter</code> class and override the <code class="prettyprint">generateReport</code> method. The following listing shows a custom implementation that generates a simple Pie Chart instead of reporting information to the console.</p>

<pre class="prettyprint">
public class MyCustomBatchReporter extends DefaultBatchReporterImpl {

    /**
    * The file in which render the chart
    */
    private String reportFile;

    public MyCustomBatchReporter(String reportFile) {
        this.reportFile = reportFile;
    }

    @Override
    public void generateReport() {
        PieDataset dataset = createDataset();
        JFreeChart chart = createChart(dataset);
        try {
            ChartUtilities.saveChartAsPNG(new File(reportFile), chart, 600, 400);
        } catch (IOException e) {
            System.err.println("an error occurred when generating chart report, using default report.");
            super.generateReport();
        }
    }

    /**
    * Create a dataset with record metrics
    * @return populated dataset
    */
    private PieDataset createDataset() {
        DefaultPieDataset dataset = new DefaultPieDataset();
        dataset.setValue("Total ignored records", batchReport.getIgnoredRecordsNumber());
        dataset.setValue("Total rejected records", batchReport.getRejectedRecordsNumber());
        dataset.setValue("Total processed records",
                batchReport.getTotalInputRecordsNumber() - (
                batchReport.getRejectedRecordsNumber() + batchReport.getIgnoredRecordsNumber()
                ));
        return dataset;
    }

    /**
    * Create a chart from a dataset
    * @param dataset the input data set
    * @return populated chart
    */
    private JFreeChart createChart(PieDataset dataset) {

        JFreeChart chart = ChartFactory.createPieChart(
        "My custom Batch Report", dataset, true, true, false
        );

        PiePlot plot = (PiePlot) chart.getPlot();
        plot.setLabelFont(new Font("SansSerif", Font.PLAIN, 12));
        plot.setCircular(false);
        return chart;

    }

}
</pre>

            <p>The figure below shows a sample chart report generated with this implementation:</p>

            <div align="center"><img src="../resources/img/customReport.jpg"/></div>

            <br/>
            <p>At this point, we have implemented a custom report generator, but how to tell CB4J to use this custom implementation instead of the default one?
                CB4J API provides a method to register a custom batch reporter:</p>

<pre class="prettyprint">
batchConfiguration.registerBatchReporter(new MyCustomBatchReporter("/data/cb4j/chartReport.png"))
</pre>

            </div>

        </div>

    </div>

    <hr>

    <footer>
        <p class="pull-right"><a href="#"><i class="icon-circle-arrow-up"></i> Back to top</a></p>
        <p>CB4J is maintained by <a href="mailto:md.benhassine@gmail.com?subject=[CB4J]"><i class="icon-envelope"></i> benas</a> at <a href="https://github.com/benas/cb4j"><i class="icon-github"></i> Github</a></p>
    </footer>

</div>

<script src="../resources/js/jquery.js"></script>
<script src="../resources/js/bootstrap.min.js"></script>

</body></html>